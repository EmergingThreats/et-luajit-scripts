--[[
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
Detection for CVE-2015-2426
This lua script can be run standalone and verbosely on an OTF
echo "run()" | luajit -i <script name> <otf file>
Darien Huss
--]]

local struct = require 'struct'

function init (args)
    local needs = {}
    needs["http.response_body"] = tostring(true)
    return needs
end

function otf_handler(t,verbose)
    local WVEgAxU = 0
    local PhV2Deb1fHUAi,endpos = string.find(string.sub(t,1,512),"GPOS",8,true)
    if PhV2Deb1fHUAi then
        if (verbose==1) then print("Checking for exploit...") end
        local Vd3AFbk = struct.unpack(">I4",string.sub(t,PhV2Deb1fHUAi+8,PhV2Deb1fHUAi+12))
        local NZo5wPCdmTn = struct.unpack(">I4",string.sub(t,PhV2Deb1fHUAi+12,PhV2Deb1fHUAi+16))
        local NXtxJvRJ = string.sub(t,Vd3AFbk+1,Vd3AFbk+NZo5wPCdmTn)
        local pSNaGDy = struct.unpack(">I2",string.sub(NXtxJvRJ,9,10))+1
        local cYcZE9s = struct.unpack(">I2",string.sub(NXtxJvRJ,pSNaGDy,pSNaGDy+1))
        local iHs8zqgjy4QyT = 1
        while iHs8zqgjy4QyT <= cYcZE9s do
            local DgWqpedv = (iHs8zqgjy4QyT*2)+pSNaGDy
            local u08TCBCnj = struct.unpack(">I2",string.sub(NXtxJvRJ,DgWqpedv,DgWqpedv+1))+pSNaGDy
            local VoLITs6 = struct.unpack(">I2",string.sub(NXtxJvRJ,u08TCBCnj,u08TCBCnj+1))
            if VoLITs6 == 2 then
                local IeQOBuOD = struct.unpack(">I2",string.sub(NXtxJvRJ,u08TCBCnj+4,u08TCBCnj+5))
                local MAZNeQmgS1I = 1
                while MAZNeQmgS1I <= IeQOBuOD do
                    local zTBD0U8w = (MAZNeQmgS1I*2)+u08TCBCnj+4
                    local ivLd40p = struct.unpack(">I2",string.sub(NXtxJvRJ,zTBD0U8w,zTBD0U8w+1))+u08TCBCnj
                    local zlLlUQJN3vj = struct.unpack(">I2",string.sub(NXtxJvRJ,ivLd40p,ivLd40p+1))
                    if zlLlUQJN3vj == 2 then
                        if struct.unpack(">I2",string.sub(NXtxJvRJ,ivLd40p+12,ivLd40p+13)) == 0 or
                            struct.unpack(">I2",string.sub(NXtxJvRJ,ivLd40p+14,ivLd40p+15)) == 0 then
                            WVEgAxU = 1
                            if (verbose==1) then print("Found exploit...") end
                        end
                    end
                    MAZNeQmgS1I = MAZNeQmgS1I + 1
                end
            end
            iHs8zqgjy4QyT = iHs8zqgjy4QyT + 1
        end
    end
    return WVEgAxU
end

function common(t,o,verbose)
    rtn = 0
    if string.sub(t,1,4) == "OTTO" then
        rtn = otf_handler(t,verbose)
    end
    return rtn
end

function match(args)
    local t = tostring(args["http.response_body"])
    local o = args["offset"]
    return common(t,o,0)
end

function run()
  local f = io.open(arg[1])
  local t = f:read("*all")
  f:close()
  common(t,4,1)
end